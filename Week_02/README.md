学习笔记


| 数据结构   | 时间    |         |         |         |         |         | 空间      | 特性                     |
| ---------- | :------ | ------- | ------- | ------- | ------- | ------- | :-------- | :----------------------- |
|            | 平均    |         |         | 最差    |         |         | 最差      |                          |
|            | 访问    | 插入    | 删除    | 访问    | 插入    | 删除    |           |                          |
| 数组       | O(1)    | O(n)    | O(n)    | O(1)    | O(n)    | O(n)    | O(n)      | 在内存中占据连续空间     |
| 链表       | O(n)    | O(1)    | O(1)    | O(n)    | O(1)    | O(1)    | O(n)      | 一个节点指向另外一个节点 |
| 跳表       | O(logn) | O(logn) | O(logn) | O(n)    | O(n)    | O(n)    | O(n logn) | 建立了logn -1级的索引    |
| 栈         | O(n)    | O(1)    | O(1)    | O(n)    | O(1)    | O(1)    | O(n)      | 后进先出                 |
| 队列       | O(n)    | O(1)    | O(1)    | O(n)    | O(1)    | O(1)    | O(n)      | 先进先出                 |
| 哈希表     | O(1)    | O(1)    | O(1)    | O(n)    | O(n)    | O(n)    | O(n)      | 将键映射到表中一个位置   |
| 二叉查找树 | O(logn) | O(logn) | O(logn) | O(n)    | O(n)    | O(n)    | O(n)      | 左子树<根节点<右子树     |
| 红黑树     | O(logn) | O(logn) | O(logn) | O(logn) | O(logn) | O(logn) | O(n)      | 5个性质                  |





重要知识点回顾

- 哈希表
  - 哈希表将键值映射到表中一个位置，这种映射由映射函数或散列函数来完成。不同的键值可能映射到相同的位置，这种情况被称为哈希冲突，产生冲突的元素通常用链表保存起来。不同的哈希表实现对此有不同的处理，比如说HashMap，HashMap将冲突的元素先用链表保存起来，当元素的数量超过8个后，再将链表转换成红黑树。再比如说ThreadLocalMap，ThreadLocalMap将冲突的元素顺延至数组中下一个为空的位置。
  - 当我们在分析问题的时候，如果遇到类似字符出现的次数，元素出现的频率这种特点的时候，我们应当想到哈希表这种结构。
  - 相关的练习题目包括：有效的字母异位词，字母异位词分组，前k个高频元素
- 树
  - 多叉树
    - dfs
      - 前序
      - 后序
    - bfs
  - 二叉树
    - 二叉搜索树
      - 左子树小于根节点，根节点小于右子树
    - 二叉平衡树
      - 任意节点的左右子树的深度之差不会超过1
    - 红黑树
      - 5个性质
        - 节点要么是黑色，要么是红色
        - 根节点是黑色
        - 叶子节点和null为黑色
        - 红节点的两个子节点为黑色
        - 树中任意一节点到叶子节点的路径都包含数量相同的黑节点
      - 两种关键操作
        - 左旋：将支点的右子节点置为支点的父节点，支点变为右子节点的左子节点，右子节点的左子节点变为支点的右子节点。
        - 右旋：将支点的左子节点置为支点的父节点，支点变为左子节点的右子节点，左子节点的右子节点变为支点的左子节点。
    - dfs
      - 前序：根左右
      - 中序：左根右
      - 后序：左右根
    - bfs
  - 树的解法多是递归的原因，是因为从根节点到子节点的过程和函数调用的过程一样，并且根节点和子节点的处理逻辑是一致的，所以不停的调用自己，这也就是递归。
  - 相关的练习题目包括：二叉树的前序，中序，后序及N叉树的前序后序的递归及循环解法。
- 堆：用O(1)的事件取出最大值或最小值。插入删除的时间复杂度不超过O(logn)。
  - 常见的实现
    - 二叉堆
      - 是一颗完全二叉树
      - 树中任意节点的值总是大于等于子节点的值
      - 实现细节
        - 使用数组作为容器
        - 假设堆顶元素位于索引0处，则
          - i处的左子节点的索引为 i<<1+1
          - i处的右子节点的索引为 i<<1+2
          - i处的父节点的索引 i >>> 1
        - 插入：新元素插入堆的尾部，然后将新元素依次上浮，也就是向上调整堆的结构
        - 删除：将堆尾元素置于被删除元素处，然后将堆尾元素依次下沉，也就是向下调整堆的结构
      - 二叉堆是一种常见且简单的实现，但不是最优的实现。PriorityQueue的实现就是一个二叉堆。
    - 严格的斐波那契堆，在堆的各种实现中性能最好，只有删除堆顶元素的时间为O(logn)其余皆为O(1)。
  - 相关的题目包括：前k个高频元素，滑动窗口的最大值，最小的k个数。
- 图：由点和边组成，点有入度和出度，点与点之间是否连通。边分为有向和无向，边长可以带有权重。
  - 无向无权图
  - 有向无权图
  - 无向有权图
  - 有向有权图？
- 动态规划
  - 适用条件（递推的解决问题）
    - 最优子结构
    - 重复子问题
    - 无后效性
      - 接雨水与柱状图中的最大矩形，无法用动态规划，就是因为第i个柱子能接的雨水数量或能形成的最大矩形不仅取决于左边的边界，还取决于右边的元素，我想这便是不能用动态规划的原因吧。
  - 编码模板
    - 状态表示
    - 状态转移
      - 其实就是寻找f(i)与f(i-1)之间的关系，斐波那契数列非常典型。最长不含重复字符的子字符串，礼物的最大价值等等。
    - 边界情况



这周阅读了jdk1.8版本的HashMap，PriorityQueue，ThreadLocalMap的源码，有了数据结构的知识后，分析这些类的源码就变得容易了，也就能轻松掌握这些类，数据结构和算法是学习计算机必须掌握的基本功。这周在刷题的时候也是遵循五毒神掌的教诲，不死磕，过遍数。

